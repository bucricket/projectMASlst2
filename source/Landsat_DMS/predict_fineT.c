/*************************************************************************/
/*									 */
/*	Source code for use with Cubist Release 2.02			 */
/*	--------------------------------------------			 */
/*		   Copyright RuleQuest Research 2005			 */
/*									 */
/*	This code is provided "as is" without warranty of any kind,	 */
/*	either express or implied.  All use is at your own risk.	 */
/*									 */
/*************************************************************************/


/*************************************************************************/
/*									 */
/*	Sample program to demonstrate the use of Cubist models		 */
/*	------------------------------------------------------		 */
/*									 */
/*	Compilation:							 */
/*									 */
/*	    Unix: use an ANSI C compiler such as gcc and include	 */
/*		  the math library, e.g. gcc -O2 sample.c -lm		 */
/*									 */
/*	    Windows: compile as a console application with symbol	 */
/*		  "WIN32" defined					 */
/*									 */
/*	The options for this program are:				 */
/*									 */
/*	    -f <filestem>   specify the application name		 */
/*	    -p		    print the cubist model			 */
/*									 */
/*	The program expects to find the following files:		 */
/*									 */
/*	    <filestem>.names (the application names file)		 */
/*	    <filestem>.model (the model file generated by Cubist)	 */
/*	    <filestem>.cases (with the same format as a .data file) 	 */
/*	    <filestem>.data  (the training data, if the Cubist model	 */
/*			      uses instances as well as rules)		 */
/*									 */
/*	Please note: the names file and data file (if required)		 */
/*	must be exactly as they were when the model was generated.	 */
/*									 */
/*	For each case in <filestem.cases>, the program prints the	 */
/*	target value and then the value predicted by the model.		 */
/*									 */
/*	Revised November 2005						 */
/*									 */
/*************************************************************************/


#include "defns.h"
#include "global.c"
#include "hooks.c"


/** 
 *  This program was adopted and revised from freely available cubist prediction example
 *  program. The program has been revised to accept input from binary/GeoTIFF images. 
 *  the cubist regression tree must be first built (using get_samples.exe program to extract
 *  T-R samples and then use cubist program to train T-R samples)
 *  
 *  Revised by Feng Gao on July 2012 
 *  v1.0 original version for Landsat TIR imagery
 *  v1.1 modified for MODIS TIR sharpening using MODIS 8-day NDVI 
 *  v1.2 combined previous revisions from 201405 and 201408 (10/29/2015)
 * v1.3 modified sharpening according to view zenith angle (11/11/2015)
 */

#include "landsat.h"

int main(int Argc, char *Argv[])
/*  ----  */
{
    FILE		*F;
    Description		Case;
    int			m;
    float		Predicted;
    extern String	OptArg, Option, PropVal;
    RRuleSet		*CubistModel;
    char		Msg[100];
    Boolean		PreviewModel=false;

    int i, j, k, nrows, ncols, nbands, valid, sum, si;
    int16 data[6];
    float ndvi, fc;
    INPUT_PARS *pars;
    SENSOR     *shortw, *cth, *oth, *sth;

    pars = malloc(sizeof(INPUT_PARS));
    shortw = malloc(sizeof(SENSOR));  /* input spectral */
    cth   = malloc(sizeof(SENSOR));  /* original input thermal band */
    oth   = malloc(sizeof(SENSOR));  /* resized thermal band */
    sth  = malloc(sizeof(SENSOR));  /* output sharpened thermal */
 
    /*  Process options  */
    switch(Argc) {
    case 2: 
      parseParameters(Argv[1], pars); 
      break;
    case 6: 
      parseParameters(Argv[1], pars); 
      pars->s_row = atoi(Argv[2]);
      pars->s_col = atoi(Argv[3]);
      pars->e_row = atoi(Argv[4]);
      pars->e_col = atoi(Argv[5]);
      break;
    default: 
      fprintf(stderr, "\nUsage: %s <in_parameter_file>", Argv[0]);
      fprintf(stderr, "\nor:    %s <in_parameter_file> <s_row> <s_col> <e_row> <e_col> (in coarse res)\n", Argv[0]);
      return FAILURE;
    }

#ifdef DEBUG
    printoutParameters(pars);
#endif
    
    printf("- loading cubist regression tree ...");
    FileStem = pars->cubistFile;

    /*  Read information on attribute names and values  */
    if ( ! (F = GetFile(".names", "r")) ) Error(0, Fn, "");
    GetNames(F);

    /*  Read the model file that defines the ruleset and sets values
	for various global variables such as USEINSTANCES  */
    CubistModel = GetCommittee(".model");

    if ( PreviewModel )
    {
	/*  Display the rulesets  */
	ForEach(m, 0, MEMBERS-1)
	{
	    if ( MEMBERS > 1 )
	    {
		sprintf(Msg, "Model %d:", m+1);
	    }
	    else
	    {
		sprintf(Msg, "Model:");
	    }

	    PrintRules(CubistModel[m], Msg);

	}
    }

    if ( USEINSTANCES )
    {
	if ( ! (F = GetFile(".data", "r")) ) Error(0, Fn, "");
	GetData(F, true, false);

	/*  Prepare the file of instances and the kd-tree index  */

	InitialiseInstances(CubistModel);

	free(Item);
	if ( PreviewModel ) printf("\nUsing instances (%d nearest neighbors)"
				   " together with rules\n\n", NN);
    }
    else
    if ( PreviewModel )
    {
	printf("\nUsing rules alone\n\n");
    }


   /* get metadata from inputs */
    if(getSensorMetaInfo(shortw, oth, cth, sth, pars)==FAILURE) {
      fprintf(stderr, "\nmain: Retrieve Sensor metadata error\n");
      return FAILURE;
    }

    /* use the entire image if not defined */
    if(Argc == 2) {
      pars->s_row = 0;
      pars->s_col = 0;
      pars->e_row = cth->nrows;
      pars->e_col = cth->ncols;
    }

    openForWrite(sth);

    nbands = shortw->nbands;
    nrows = shortw->nrows;
    ncols = shortw->ncols;

 #ifdef DEBUG
    for(i=0; i<nbands; i++) 
      printf("\nBand_%d: %s ", i, pars->inFile[i]);
    printf("\nImage size in nrows and ncols: %d %d ", nrows, ncols);
 #endif

    printf("\n- loading thermal data from original resolution file ...");
    /* read all thermal data to memory */
    loadThermal(oth);
    
    printf("\n- processing image line by line ... ");

    Case = AllocZero(MaxAtt+6, AttValue);

    /*for(k=1;k<=MaxAttVal[3]; k++)	  
      printf("%s = %d\n", AttValName[3][k], k);*/

    /* Now process the case in binary image file */
    for(i=0; i<nrows; i++) {

      if(i<pars->s_row*sth->scale || i>pars->e_row*sth->scale) continue;

      fprintf(stderr,"%4d\b\b\b\b", i);

      loadSensorRow(shortw, i);

      for(j=0; j<ncols; j++)
	{
	  if(j<pars->s_col*sth->scale || j>pars->e_col*sth->scale) continue;

	  valid = 1;
	  for(k=0; k<nbands; k++) {
	    data[k] = shortw->data[k][j];
	    if(data[k]==shortw->fillValue || data[k]<shortw->range[0] || data[k]>shortw->range[1]) 
	      valid = 0;
	  }
	  
	  /* exclude pixels with all zero */
	  sum = 0;
	  for(k=0; k<nbands; k++) 
	    sum += shortw->data[k][j];
	  if(sum==0) valid = 0;   

	  if(valid == 1) {
	    
	    si = 1;
	    CVal(Case, si++) = i;
	    CVal(Case, si++) = j; 

	    for(k=0; k<nbands; k++)
	      CVal(Case, k+si) = data[k];

	    /*ndvi = (float)(data[1]-data[0])/(float)(data[1]+data[0]);*/
	    /* for airborne data test only */
	    /*ndvi = (float)(data[0]-data[1])/(float)(data[0]+data[1]);*/
	    /*CVal(Case, nbands+si) = ndvi;*/
	    /* CVal(Case, nbands+si+1) = fc;*/

	    ndvi = data[0]/10000.0;
	    fc = pow((1-ndvi), 0.625);
	    CVal(Case, nbands+si) = fc;

	    /*ReplaceUnknowns(Case, Nil);*/
	    Predicted = ( USEINSTANCES ? NNEstimate(CubistModel, Case, &GNNEnv) :
			  PredictValue(CubistModel, Case) );
	    if(isnan(Predicted)) Predicted = FILLV;

#ifdef DEBUG
	    if(i==DEBUG_irow&&j==DEBUG_icol) {

	      printf("\nInput: i=%d j=%d, ", i, j);
	      for(k=0; k<nbands; k++)
		printf("%d, ", data[k]);
	      printf("\nProgram Value: ");
	      for(k=0; k<2; k++)
		printf("%4.0f ", CVal(Case, k+1));
	      for(k=3; k<nbands+3; k++)
		printf("%4.0f ", CVal(Case, k));
	      for(k=nbands+3; k<nbands+5; k++)
		printf("%6.4f ", CVal(Case, k));
	      printf("\npredict=%5.1f  original=%5.1f\n", Predicted, oth->fdata[i][j]);

	    }
#endif

	  }
	  else 
	    /* use fill value if prediction fails */
	    Predicted = FILLV;
	  
	  sth->fdata[i][j] = Predicted;

	}
    }
    
    
    FreeCttee(CubistModel);
    
    if ( USEINSTANCES )
    {
	FreeCases(Instance, MaxInstance);
	FreeUnlessNil(Ref);
	FreeUnlessNil(RSPredVal);
	FreeUnlessNil(GNNEnv.AttMinD);
	FreeIndex(KDTree);
    }

    FreeNamesData();
    FreeUnlessNil(PropVal);
    FreeUnlessNil(IgnoredVals);

    printf("\n- aggregating original temperature to corase (actual) resolution ...");
    resize(oth, cth);

    printf("\n- applying residuals to model predictions ...");
    applyEC(shortw, oth, cth, sth, pars);

    printf("\n- cleaning up memory and closing files ...");
    cleanUpSensor(shortw, oth, cth, sth);

    free(shortw);
    free(oth);
    free(cth);
    free(sth);
    free(pars);

    printf("\n- program ends successfully\n");
    return SUCCESS;
}

